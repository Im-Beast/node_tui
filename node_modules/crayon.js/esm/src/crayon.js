// Copyright 2022 Im-Beast. All rights reserved. MIT license.
import { ansi3, ansi4, ansi8, attributes, colors, hex, hsl, keyword, rgb, } from "./styles.js";
import { getNoColor, replaceAll } from "./util.js";
const hasColor = !getNoColor();
/** An object that expresses how well terminal supports displaying colors */
export const colorSupport = {
    noColor: !hasColor,
    trueColor: hasColor,
    highColor: hasColor,
    fourBitColor: hasColor,
    threeBitColor: hasColor,
};
/** Map containing all style functions used by crayon */
export const functions = new Map();
/** Map containing all styles used by crayon */
export const styles = new Map();
/** Array containing all crayons that have been cached */
const cachedCrayons = [];
/** Object, which gets set as the prototype of every generated crayon instance in `generateCrayon()` function */
export const prototype = {
    get colorSupport() {
        return colorSupport;
    },
    set colorSupport(value) {
        // Keep colorSupport object reference so it doesn't break things
        Object.assign(colorSupport, value);
        // Re-cache every crayon instance that has been cached
        // It's done to make sure that they obey colorSupport
        for (const crayon of cachedCrayons) {
            crayon.reprepareCache();
        }
    },
    strip(text) {
        return text.replaceAll(/\x1b\[([0-9]|;)+m/gi, "");
    },
    optimize(text) {
        let $text = text;
        let lenDiff = 0;
        do {
            text = $text
                .replaceAll(/\x1b\[([0-9]|;)+m\x1b\[0m/gi, "\x1b[0m")
                .replaceAll(/(\x1b\[4([0-9]|;)+m)((\x1b\[([0-9]|;)+m)*(\x1b\[4([0-9]|;)+m))/gi, "$3").replaceAll(/(\x1b\[3([0-9]|;)+m)((\x1b\[([0-9]|;)+m)*(\x1b\[3([0-9]|;)+m))/gi, "$3");
            lenDiff = text.length - $text.length;
            $text = text;
        } while (lenDiff !== 0);
        return text;
    },
    literal() {
        throw new Error("You need to import extension for literal template support to be able to use it");
    },
};
export function buildCrayon(styleBuffer = "", usesFunc = false) {
    function crayon(single, ...many) {
        if (single?.raw)
            return prototype.literal(single, ...many);
        // Improve performance when only one parameter is given
        const text = many.length ? `${single} ${many?.join(" ")}` : `${single}`;
        if (!styleBuffer)
            return text;
        return styleBuffer +
            replaceAll(text, "\x1b[0m\x1b[0m", "\x1b[0m" + styleBuffer) +
            "\x1b[0m\x1b[0m";
    }
    crayon.styleBuffer = styleBuffer;
    crayon.usesFunc = usesFunc;
    return Object.setPrototypeOf(crayon, prototype);
}
/**
 * ðŸ–ï¸ Crayon object that's used for styling
 *  - Call the last property as a function with arguments to get styled string
 *
 * @example
 * ```ts
 * import { crayon } from ...;
 *
 * const info = crayon.bgBlue.white;
 *
 * console.log(
 *  info("You can cache styles like that!"),
 *  crayon.bgMagenta.black("You can also", "pass multiple arguments!")
 * );
 * ```
 *
 * When `extensions/literal.ts` is imported literal template styling is possible
 *
 * @example
 * ```ts
 * import { crayon } from ...;
 * import ".../src/extensions/literal.ts";
 *
 * console.log(
 *  crayon`{red This text is red {green this is green} and again red}`,
 *  crayon`{rgb(230,30,20) I love colors by the way}`
 * );
 * ```
 */
export const crayon = buildCrayon();
/**
 * Map given style function to `name` and `bgName` keys in `prototype`
 * When `only` is set to true only `name` key is set and no additional parameters are added when calling function
 *
 * @param name â€“ name of the function
 * @param func â€“ function which gets mapped
 * @param noBgSpecifier â€“ whether to not map bgName func (also won't call additional false argument)
 */
function mapFunc(name, func, noBgSpecifier = false) {
    functions.set(name, func);
    if (noBgSpecifier) {
        Object.defineProperty(prototype, name, {
            value: colorSupport.noColor
                ? function () {
                    return crayon;
                }
                : function (...args) {
                    return buildCrayon(this.styleBuffer + (func(...args) ?? ""), true);
                },
        });
        return;
    }
    Object.defineProperty(prototype, name, {
        value: colorSupport.noColor
            ? function () {
                return crayon;
            }
            : function (...args) {
                return buildCrayon(this.styleBuffer + (func(...args, false) ?? ""), true);
            },
    });
    const bgName = `bg${name[0].toUpperCase() + name.slice(1)}`;
    Object.defineProperty(prototype, bgName, {
        value: colorSupport.noColor
            ? function () {
                return crayon;
            }
            : function (...args) {
                return buildCrayon(this.styleBuffer + (func(...args, true) ?? ""), true);
            },
    });
}
export function mapPrototypeFuncs(...iterable) {
    if (typeof iterable[0] === "function") {
        for (const func of iterable) {
            mapFunc(func.name, func);
        }
        return;
    }
    for (const map of iterable) {
        for (const [name, func] of map.entries()) {
            mapFunc(name, func);
        }
    }
}
/**
 * Map given style to `name` key in `prototype`
 *
 * @param name â€“ name of the style
 * @param code â€“ style code which will get mapped
 */
function mapStyle(name, code) {
    styles.set(name, code);
    const attributes = {
        configurable: true,
    };
    if (colorSupport.noColor) {
        attributes.value = crayon;
    }
    else {
        attributes.get = function () {
            const prepareCrayon = () => {
                const $code = typeof code === "function" ? code() : code;
                const builtCrayon = buildCrayon(this.styleBuffer + $code, this.usesFunc);
                // Instead of building crayon every time property gets accessed
                // simply replace getter with built crayon instance
                Object.defineProperty(this, name, {
                    configurable: true,
                    value: builtCrayon,
                });
                return builtCrayon;
            };
            const preparedCrayon = prepareCrayon();
            // Don't cache crayon when it uses function:
            // This is done to prevent memory leaks or cpu overhead
            // caused when function has many different output possibilities
            if (!preparedCrayon.usesFunc) {
                preparedCrayon.reprepareCache = prepareCrayon;
                cachedCrayons.push(preparedCrayon);
            }
            return preparedCrayon;
        };
    }
    Object.defineProperty(prototype, name, attributes);
}
/**
 * Uses `mapStyle` on every given style code
 *  - map key will be used as `name` parameter
 * @param maps â€“ map which styles will get mapped
 */
export function mapPrototypeStyles(...maps) {
    for (const map of maps) {
        for (const [name, code] of map.entries()) {
            mapStyle(name, code);
        }
    }
}
// Map default stylings
mapPrototypeStyles(colors, attributes);
mapPrototypeFuncs(ansi3, ansi4, ansi8, rgb, hsl, hex);
mapFunc(keyword.name, keyword, true);
