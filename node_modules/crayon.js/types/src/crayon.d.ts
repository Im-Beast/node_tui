import { Style, StyleCode } from "./styles.js";
export interface ColorSupport {
    readonly noColor?: boolean;
    trueColor: boolean;
    highColor: boolean;
    fourBitColor: boolean;
    threeBitColor: boolean;
}
/** An object that expresses how well terminal supports displaying colors */
export declare const colorSupport: ColorSupport;
export declare type CrayonStyleFunction = (...args: any[]) => StyleCode | string | undefined;
/** Map containing all style functions used by crayon */
export declare const functions: Map<string, CrayonStyleFunction>;
/** Map containing all styles used by crayon */
export declare const styles: Map<string, StyleCode | (() => StyleCode)>;
interface CrayonPrototype {
    colorSupport: ColorSupport;
    strip(text: string): string;
    optimize(text: string): string;
    literal(...text: unknown[]): string;
}
/** Object, which gets set as the prototype of every generated crayon instance in `generateCrayon()` function */
export declare const prototype: CrayonPrototype;
/** Crayon type which can be easily extended
 * `C` - literal string type for extending styles
 * `O` - object which expands
 */
export declare type Crayon<C extends string = never, O extends Record<string, unknown> = Record<never, never>> = ((single: unknown, ...many: unknown[]) => string) & typeof prototype & {
    styleBuffer: string;
    usesFunc: boolean;
    reprepareCache?(): void;
    keyword(style: Style): Crayon<C, O>;
    keyword(style: string): Crayon<C, O>;
    ansi3(code: number): Crayon<C, O>;
    bgAnsi3(code: number): Crayon<C, O>;
    ansi4(code: number): Crayon<C, O>;
    bgAnsi4(code: number): Crayon<C, O>;
    ansi8(code: number): Crayon<C, O>;
    bgAnsi8(code: number): Crayon<C, O>;
    rgb(r: number, g: number, b: number): Crayon<C, O>;
    bgRgb(r: number, g: number, b: number): Crayon<C, O>;
    hsl(h: number, s: number, l: number): Crayon<C, O>;
    bgHsl(h: number, s: number, l: number): Crayon<C, O>;
    hex(hex: string | number): Crayon<C, O>;
    bgHex(hex: string | number): Crayon<C, O>;
} & {
    [style in Style | C]: Crayon<C, O>;
} & O;
export declare function buildCrayon<T extends Crayon = Crayon>(styleBuffer?: string, usesFunc?: boolean): T;
/**
 * üñçÔ∏è Crayon object that's used for styling
 *  - Call the last property as a function with arguments to get styled string
 *
 * @example
 * ```ts
 * import { crayon } from ...;
 *
 * const info = crayon.bgBlue.white;
 *
 * console.log(
 *  info("You can cache styles like that!"),
 *  crayon.bgMagenta.black("You can also", "pass multiple arguments!")
 * );
 * ```
 *
 * When `extensions/literal.ts` is imported literal template styling is possible
 *
 * @example
 * ```ts
 * import { crayon } from ...;
 * import ".../src/extensions/literal.ts";
 *
 * console.log(
 *  crayon`{red This text is red {green this is green} and again red}`,
 *  crayon`{rgb(230,30,20) I love colors by the way}`
 * );
 * ```
 */
export declare const crayon: Crayon<never, Record<never, never>>;
/**
 * Uses `mapFunc` on every given function
 *  - `func.name` will be considered as `name` parameter
 *
 * @param funcs ‚Äì functions which will get mapped
 */
export declare function mapPrototypeFuncs(...funcs: CrayonStyleFunction[]): void;
/**
 * Uses `mapFunc` on every given function
 *  - map key will be used as `name` parameter
 *
 * @param maps ‚Äì map which functions will get mapped
 */
export declare function mapPrototypeFuncs(...maps: Map<string, CrayonStyleFunction>[]): void;
/**
 * Uses `mapStyle` on every given style code
 *  - map key will be used as `name` parameter
 * @param maps ‚Äì map which styles will get mapped
 */
export declare function mapPrototypeStyles(...maps: (Map<string, (() => StyleCode) | StyleCode>)[]): void;
export {};
